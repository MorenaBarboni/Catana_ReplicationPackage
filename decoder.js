/**
 * DECODER - This module includes the logic for analyzing the storage data and decoding state variables
 */
const catanaConfig = require('./catana-config');
//External modules
const { ethers } = require("ethers");
const path = require('path');
//Catana modules
const fetch = require('./fetchProcessingData');
const scraper = require('./scraper');


/**
 * EXTRACT AND ANALYZE THE BUILD-INFO DATA
 */

/**
 * Filters storage layout data for a specific contract sourceName
 * @param {String} sourcePath source path of a contact (e.g.: ./contracts/Proxy.sol)
 * @param {String} [artifactsDirPath="./artifacts"] the path to the hardhat directory that contains the compiled artifacts (artifacts by default)
 * @returns filtered storageLayout for a contract
 */
function getStorageLayoutBySource(sourcePath, artifactsDirPath = "./artifacts") {
    console.log("- Reading storage layout of " + sourcePath + " from: " + artifactsDirPath)
    const buildInfoData = fetch.readBuildInfoFiles(artifactsDirPath);
    const storageLayout = extractStorageLayout(buildInfoData);
    const allSourceASTs = getAllSourceASTs(buildInfoData);

    let filteredLayout = storageLayout.filter(v => path.normalize(v.source) === path.normalize(sourcePath));
    let filteredLayoutArray = filteredLayout.map(item => item);

    filteredLayoutArray.forEach(sVar => {
        const parentContractData = getParentSource(sVar, allSourceASTs);
        sVar.parentContract = parentContractData.contract;
        sVar.parentSource = parentContractData.source;
    });

    return filteredLayoutArray;
}

/**
 * Extracts the storage layout for all contract sources in all files of the build-info data
 * @param {Object} buildInfoData - the buildInfo data of all build-info files generated by hardhat
 * @returns a list of state variables with their storage information
 */
function extractStorageLayout(buildInfoData) {
    let storageLayout = [];

    //Cycle all build info files
    for (const buildInfoFile in buildInfoData) {
        const buildInfoFileData = buildInfoData[buildInfoFile];
        const sources = extractSourcesFromBuildInfoFile(buildInfoFileData);

        sources.forEach(sourceName => {

            let sourceOutputContracts; //All output.contracts for the source
            //let sourceAST; //AST for the source

            if (buildInfoFileData.output.contracts[sourceName]) {
                //Extract source outputs - each source might contain multiple contracts
                sourceOutputContracts = buildInfoFileData.output.contracts[sourceName];

                //List of contracts included in the source
                const contractsInSource = Object.keys(sourceOutputContracts);

                contractsInSource.forEach(contractName => {

                    if (sourceOutputContracts[contractName].storageLayout) {
                        let contractStorageLayout = sourceOutputContracts[contractName].storageLayout;

                        if (contractStorageLayout.storage) {
                            contractStorageLayout.storage.forEach(stateVar => {
                                if (!isBlackListed(stateVar)) {
                                    let varInfo = {
                                        name: stateVar.label,
                                        slot: stateVar.slot,
                                        offset: stateVar.offset,
                                        type: stateVar.type,
                                        numberOfBytes: sourceOutputContracts[contractName].storageLayout.types[stateVar.type].numberOfBytes,
                                        astId: stateVar.astId,
                                        source: sourceName,
                                        contract: contractName,
                                        numberOfElements: null
                                    };
                                    storageLayout.push(varInfo)
                                }
                            });
                        }
                    }
                });
            }
        });
    }
    return (storageLayout);
}

/**
 * It scrapes Etherscan's accountstatediff page to identify the slots of the mapping elements that
 * are impacted by a given transaction.
 * The slots are saved into a single, generic state variable of type "t_custom_mapping_elements"
 *  
 * @param {Object} storageLayoutWithValues - the storage layout of the Proxy with the state variable values
 * @param {string} txHash - the hash of the transaction
 * @param {string} proxyAddress - the address of the Proxy contract
 * @returns a state variable of type t_custom_mapping_elements (or null)
 */
async function getChangedMappingSlots(storageLayoutWithValues, txHash, proxyAddress) {
    const scrapingResults = await scraper.scrapePage(txHash);

    let changedSlots;
    let mappingSVar = {
        name: "mapping_elements",
        type: "t_custom_mapping_elements",
        numberOfElements: 0,
        parentSource: "unknown",
        slot: "unknown",
        value: {}
    }

    //If some slots underwent changes
    if (scrapingResults && scrapingResults !== null && scrapingResults.length > 0) {

        //Extract Account State Diff for the Proxy contract only
        const proxyScrapingResults = scrapingResults.find(item => proxyAddress.startsWith(item.Address.split("...")[0]));

        if (proxyScrapingResults !== undefined && proxyScrapingResults !== null) {
            const allChangedSlots = proxyScrapingResults.ChangedSlots;

            //Only keep storage slots that start with 0x - might be a mapping slot
            changedSlots = allChangedSlots.filter(item => item.startsWith('0x'));

            //If the slot is not already included in the extracted storage layout, it should be a mapping
            const stringifiedStorageLayout = JSON.stringify(storageLayoutWithValues);
            changedSlots.forEach(changedSlot => {
                //Set slot as a key in the value field, and init to null
                if (!stringifiedStorageLayout.includes(changedSlot)) {
                    mappingSVar.value[changedSlot] = null;
                    mappingSVar.numberOfElements++;
                }
            });

            if (Object.keys(mappingSVar.value).length > 0)
                return mappingSVar;
        }
    }
    return null
}

/**
 * Given a state variable, it determines whether it should be included in the storage layout to be analyzed
 * Blacklisted state variables include:
 *               - storage variables declared within certain libraries - todo
 *               - storage gap variables
 *               - user defined storage variables - todo
 * @param {Object} contractStorageLayout  - the contract storage layout
 * @returns true if the variable is blacklisted
 */
function isBlackListed(sVar) {
    let blacklistedStateVarNames = catanaConfig.stateVarsBlacklist;
    return blacklistedStateVarNames.includes(sVar.label)
}

/**
 * Extracts the list of contract sources in a specific build info data file
 * @param {Object} buildInfoFileData - the build info data for a specific file
 * @returns the list of contract sources in a specific build info data
 */
function extractSourcesFromBuildInfoFile(buildInfoFileData) {
    const sources = buildInfoFileData.input.sources;
    const sourceList = Object.keys(sources);

    return sourceList;
}

/**
 * Extracts the AST for all sources from the build-info data
 * @param {Object} buildInfoData the build info data for all contracts
 * @returns the ASTs of all sources in the build info data
 */
function getAllSourceASTs(buildInfoData) {
    let sourcesASTs = [];
    for (const buildInfoFile in buildInfoData) {
        const buildInfoFileData = buildInfoData[buildInfoFile];
        const sources = extractSourcesFromBuildInfoFile(buildInfoFileData);
        sources.forEach(source => {
            sourcesASTs.push(getSourceAST(source, buildInfoFileData))
        });
    }
    return sourcesASTs;
}

/**
 * Extracts the AST for a given source from a build-info file
 * @param {Object} source the source contract path (e.g., 'contracts/FiatTokenV2_1.sol')
 * @param {Object} buildInfoFileData the build info data for a single file
 * @returns the list of contract sources in a specific build info data
 */
function getSourceAST(source, buildInfoFileData) {
    let sourceAST;
    if (buildInfoFileData.output?.sources[source].ast) {
        sourceAST = buildInfoFileData.output.sources[source].ast;
    }
    return sourceAST;
}


/**
 * It returns the name and source of the contract where a given state variable was declared
 * @param {Object} sVar - the stateVariable to be analyzed
 * @param {Object} astList - ASTs of all contract sources
 * @returns an object containing the name and the source of the contract where the variable is declared
  */
function getParentSource(sVar, astList) {
    let parentContractData = { contract: null, source: null }

    for (const ast of astList) {
        // Check if the AST contains nodes
        if (ast.nodes) {
            // Iterate through the nodes to find contracts
            for (const node of ast.nodes) {
                if (node.nodeType === 'ContractDefinition') {
                    parentContractData.contract = node.name;
                    // Check if the contract has state variables
                    if (node.nodes) {
                        // Iterate through the contract's nodes to find state variables
                        for (const contractNode of node.nodes) {
                            if (contractNode.nodeType === 'VariableDeclaration' && contractNode.stateVariable
                                && contractNode.name === sVar.name && contractNode.id === sVar.astId) {
                                // Return the AST if the state variable is found in this contract
                                parentContractData.source = ast.absolutePath;
                                return parentContractData;
                            }
                        }
                    }
                }
            }
        }
    }
    // Return null if the state variable is not found in any contract
    return null;
}

/**
 * DECODE STORAGE VARIABLE VALUES
 */

/**
 * Given the storage layout data, it adds a decodedValue property to each of its variables
 * @param {Object} storageLayoutWithValues - storage layout composed of state variables with their values
 * @returns storageLayoutWithValues with an added 'decodedValue' field
 */
function decodeStorageValues(storageLayoutWithValues) {
    storageLayoutWithValues.forEach(sVar => {
        const decodedValue = decodeVariableValue(sVar.value, sVar.type, sVar.numberOfElements, sVar.parentSource, null);
        if (sVar.type !== "t_custom_mapping_elements") {
            sVar.decodedValue = decodedValue;
        }
    });
    return storageLayoutWithValues;
}

/**
 * Given a state variable data, it decodes its value
 * @param {String|Object} value - the state variable's value to be decoded (it can be a simple value or an object composed of multiple slot-value pairs)
 * @param {String} type - the state variable's type description
 * @param {Number} numberOfElements - the number of elements packed in the same slot where the state variable is stored (only used for bool arrays)
 * @param {String} parentSource - the state variable's parent source (e.g.: contracts/Gala.sol)
 * @param {Number} astId - the state variable astId (e.g. - 5833)
 * @returns the decoded variable value (or the encoded value if not possible)
 */
function decodeVariableValue(value, type, numberOfElements, parentSource, astId) {
    if (type.startsWith("t_address") || type.startsWith("t_contract")) {
        return decodeAddress(value);
    } else if (type.startsWith("t_bool")) {
        return numberOfElements ? decodeBoolArray(value, numberOfElements) : decodeBool(value);
    } else if (type.startsWith("t_bytes")) {
        return typeof value === 'object' ? decodeLongBytes(value) : decodeShortBytes(value);
    } else if (type.startsWith("t_string")) {
        return typeof value === 'object' ? decodeLongString(value) : decodeShortString(value);
    } else if (type.startsWith("t_uint")) {
        return decodeUint(value);
    } else if (type.startsWith("t_enum")) {
        return decodeEnum(value, type, parentSource);
    } else if (type.startsWith("t_struct")) {
        return decodeStruct(value, type, numberOfElements, parentSource, astId);
    } else if (type.startsWith("t_mapping")) {
        return decodeMapping(value, type, numberOfElements, parentSource, astId);
    } else if (type.startsWith("t_array")) {
        return decodeArray(value, type, numberOfElements, parentSource, astId);
    } else if (type.startsWith("t_custom_mapping_elements")) {
        return value;
    }
    return "Decoded value N.A.";
}


/**
 * Decode a t_uint
 * @param {String} hexValue the data to decode
 * @returns the decoded uint value
 */
function decodeUint(hexValue) {
    return BigInt(hexValue).toString()
}

/**
 * Decode a short t_bytes
 * @param {String} bytesValue the data to decode
 * 
 * @returns the decoded bytes array value
 */
function decodeShortBytes(bytesValue) {
    return bytesValue
}

/**
 * Decode a long t_bytes
 * @param {String} value an object containing slot-value pairs for the long bytes array
* 
 * @returns the decoded bytes value in Object format
 */
function decodeLongBytes(value) {
    const slots = Object.keys(value);

    for (let i = 0; i < slots.length; i++) {
        value[slots[i]] = decodeShortBytes(value[slots[i]])
    }
    return value;
}

/**
 * Decode a short t_string
 * @param {String} hexValue the string data to decode
 * @returns the decoded string value
 */
function decodeShortString(hexValue) {
    let decodedString = hexValue;
    try {
        decodedString = ethers.toUtf8String(hexValue).toString();
        decodedString = decodedString.replace(/\u0000/g, '');
    } catch (error) { }

    return decodedString;
}

/**
 * Decode a long t_string
 * @param {Object} value an object containing slot-value pairs for the long string
 * @returns the decoded string value in object format
 */
function decodeLongString(value) {

    const slots = Object.keys(value);

    for (let i = 0; i < slots.length; i++) {
        value[slots[i]] = decodeShortString(value[slots[i]])
    }
    return value;
}

/**
 * Decode a t_address
 * @param {String} hexValue the data to decode
 * @returns the decoded address value
 */
function decodeAddress(hexValue) {
    if (hexValue === "0x0000000000000000000000000000000000000000000000000000000000000000")
        return "0x0000000000000000000000000000000000000000"
    return ethers.stripZerosLeft(hexValue);
}

/**
 * Decode a t_bool
 * @param {String} hexValue the data to decode
 * @returns the decoded bool value
 */
function decodeBool(hexValue) {
    if (hexValue.endsWith("1"))
        return "true"
    return "false"
}

/**
 * Decode an array of t_bool
 * @param {String} hexValue the data to decode
 * @param {Number} nElements the number of bool elements packed in the same data slot
 * @returns the decoded bool value
 */
function decodeBoolArray(hexValue, nElements) {
    const dataLength = nElements * 2;
    const data = hexValue.slice(hexValue.length - dataLength)
    let decodedValue = [];

    for (let i = 0; i < dataLength; i += 2) {
        const boolElement = data.substring(i, i + 2);
        decodedValue.push(decodeBool(boolElement));
    }

    return decodedValue.reverse();
}

/**
 * Decode a t_enum
 * @param {String} value the enum data to decode
 * @param {String} type the enum variable's type description
 * @param {String} parentSource the enum variable's parentSource * 
 * @returns the decoded enum value(s)
 */
function decodeEnum(value, type, parentSource) {
    const enumDefinitionAstId = extractEnumDefinitionAstId(type);
    const enumValues = getEnumValues(parentSource, parseInt(enumDefinitionAstId));
    if (enumValues && enumValues.length > 0) {
        return enumValues[decodeUint(value)];
    }
    return decodeUint(value);
}

/**
 * Decode a t_struct
 * @param {String} value the struct data to decode
 * @param {String} type the struct variable's type description
 * @param {Number} numberOfElements the number of elements in the same slot
 * @param {String} parentSource the struct variable's parentSource 
 * @param {Number} astId the mapping definition's astId 
 * @returns the decoded struct value
 */
function decodeStruct(value, type, numberOfElements, parentSource, astId) {
    const structDefinitionAstId = extractStructDefinitionAstId(type);
    const structAttributeTypes = getStructAttributeTypes(parentSource, parseInt(structDefinitionAstId));

    if (structAttributeTypes !== null && structAttributeTypes.length > 0) {
        let decodedValue = {};
        let i = 0;
        let extractedAttributeTypes = [];
        //If a struct includes another struct, it must be directly decoded using the attribute types of the second struct.
        // For example the struct State { Params oldParams; } includes a struct Params {uint256 a;int256 b;}
        // Its value will not contain a nested structure, but: {'slotA': 'valueOfParamA', 'slotB': 'valueOfParamb'}
        structAttributeTypes.forEach(attributeType => {
            extractedAttributeTypes = extractedAttributeTypes.concat(
                extractStructNestedAttributeTypes(attributeType, parentSource)
            );
        });
        for (const key in value) {
            decodedValue[key] = decodeVariableValue(value[key], extractedAttributeTypes[i], numberOfElements, parentSource, astId);
            i++;
        }

        return decodedValue;
    }
    return value;
}

/**
 * Decode a t_mapping
 * @param {String} value - the mapping data to decode
 * @param {String} type - the mapping variable's type description
 * @param {Number} numberOfElements - the number of elements in the same slot
 * @param {String} parentSource - the mapping variable's parentSource 
 * @param {Number} astId - the mapping definition's astId 
 * @todo for now, the decoding of mapping types is not handled due to the lack of keys
 * 
 * @returns the decoded struct value
 */
function decodeMapping(value, type, numberOfElements, parentSource, astId) {
    return value;   
}

/**
 * Decode a t_array
 * @param {String} value the array data to decode
 * @param {String} type the array variable's type description
 * @param {Number} numberOfElements the number of elements in the same slot
 * @param {String} parentSource the array variable's parentSource 
 * @param {String} astId the array definition's astId 
 * @todo - Handle nested mapping in array
 * 
 * @returns the decoded array value
 */
function decodeArray(value, type, numberOfElements, parentSource, astId) {
    const elementType = getArrayType(type);
    if (!elementType) return "Decoded value N.A.";

    //Decode array of arrays
    if (elementType.startsWith("t_array")) {
        const internalArrayType = getArrayType(elementType);
        let decodedValue = {};

        //Cycle internal array variables
        for (const arrayKey in value) {
            let decodedElement = {};
            let arrayElements = value[arrayKey].value;

            //Cycle array elements
            for (const elementKey in arrayElements) {
                decodedElement[elementKey] = decodeVariableValue(arrayElements[elementKey], internalArrayType,
                    value[arrayKey].numberOfElements, parentSource, astId);
            }
            decodedValue[arrayKey] = decodedElement;
        }
        return decodedValue;
    }
    //Decode any other array type
    else {
        let decodedValue = {};
        for (const key in value) {
            decodedValue[key] = decodeVariableValue(value[key], elementType, numberOfElements, parentSource, astId);
        }
        return decodedValue;
    }
}

/**
 * UTILITIES
 */

/**
 * Determines if an array mutability is fixed or dynamic
 * @param {String} type - the variable type description
 * @returns "fixed", "dynamic" or null
 */
function getArrayMutability(type) {
    if (type.startsWith("t_array") && !type.endsWith("dyn_storage")) {
        return "fixed"
    } else if (type.startsWith("t_array") && type.endsWith("dyn_storage")) {
        return "dynamic"
    }
    return null;
}

/**
 * Determines the type of an array's elements
 * @param {String} typeDescription - The type description string (e.g.: t_array(t_uint256)3_storage)
 * @returns the array element's type (e.g.: t_uint256), or null if it cannot be determined.
 */
function getArrayType(typeDescription) {
    const startIndex = typeDescription.indexOf('(');
    const endIndex = typeDescription.lastIndexOf(')');
    if (startIndex !== -1 && endIndex !== -1) {
        return typeDescription.substring(startIndex + 1, endIndex);
    } else {
        return null;
    }
}

/**
 * Extracts the number of elements of a fixed array from its type attribute.
 * @param {string} typeDescription - The type description string (e.g.: t_array(t_uint256)3_storage)
 * @returns {number|null} The number found after the closing parenthesis, or null if no match found.
 */
function getFixedArrayLength(typeDescription) {
    const match = typeDescription.match(/\)\s*(\d+)/);
    if (match && match.length > 1) {
        return parseInt(match[1]);
    }
    return null; // Return null if no match found
}

/**
 * Returns the length of a dynamic array. 
 * 
 * @param {String} value - the value in the starting slot of a dynamic array
 * @returns the length of the dynamic array
 */
function getDynamicArrayLength(value) {
    //The value in the starting slot of a dynamic array indicates its number of elements
    const size = decodeUint(value);
    return size;
}

/**
 * Converts a storage slot into a 32-bytes long hex string that can be processed by hardhat
 * @param {string} slot - The storage slot
 * @returns {string} The storage slot as a 32-bytes long hex string
 */
function parseSlot(slot) {
    if (slot.toString().startsWith("0x")) {
        return slot.toString();
    } else {
        const bigIntSlot = BigInt(slot);
        return ethers.toBeHex('0x' + bigIntSlot.toString(16), 32).toString();
    }
}

/**
 * Computes the keccak256 hash of a given slot
 * @param {Number} slot - The storage slot in numeric format
 * @returns {string} The keccak256 hash of the slot
 */
function computeSlotKeccak256(slot) {
    const abiCoder = new ethers.AbiCoder();
    return ethers.keccak256(abiCoder.encode(['uint256'], [parseSlot(slot)]));
}

/**
 * Determines the astId of a StructDefinition
 * @param {String} typeDescription - The struct type description string (e.g.: t_struct(Person)5791_storage)
 * @returns the astId of the variable's StructDefinition node (e.g.: 5791)
 */
function extractStructDefinitionAstId(typeDescription) {
    const regex = /(?:\w+)\((?:\w+)\)(\d+)_storage|(?:\w+)\$\w+\$(\d+)_storage/;
    const match = regex.exec(typeDescription);
    if (match) {
        return match[1] || match[2];
    } else {
        return null;
    }
}

/**
 * Recursively extracts the attribute types from a struct, including nested structs.
 *
 * @param {string} attributeType - The type of the attribute to be extracted. If it represents a struct 
 * (indicated by "t_struct" at the beginning), the function will recursively extract attribute types from 
 * the nested struct(s).
 *  @param {string} parentSource - the struct's parent source contract where it is defined.
 * @returns {string[]} An array containing all extracted attribute types. If the attribute is a struct, 
 * it will include types of its struct attributes.
 */
function extractStructNestedAttributeTypes(attributeType, parentSource) {
    let extractedAttributeTypes = [];

    if (attributeType.startsWith("t_struct")) {
        const subStructDefinitionAstId = extractStructDefinitionAstId(attributeType);
        const subStructAttributeTypes = getStructAttributeTypes(parentSource, parseInt(subStructDefinitionAstId));

        // Recursively extract types for each attribute in the sub-struct
        subStructAttributeTypes.forEach(subAttributeType => {
            extractedAttributeTypes = extractedAttributeTypes.concat(extractStructNestedAttributeTypes(subAttributeType));
        });

    } else {
        extractedAttributeTypes.push(attributeType);
    }

    return extractedAttributeTypes;
}

/**
 * Determines the astId of an EnumDefinition
 * @param {String} typeDescription - The struct type description string (e.g.: t_enum(ActionChoices)5787)
 * @returns the astId of the variable's EnumDefinition node (e.g.: 5787)
 */
function extractEnumDefinitionAstId(typeDescription) {
    const match = typeDescription.match(/\d+$/); // Match one or more digits at the end of the string
    const value = match ? match[0] : null; // Extract the matched value
    return value;
}

/**
 * Determines the type of a struct's attributes from its AST
 * @param {String} structVarSource - The struct variable parent source
 * @param {Number} structVarAstId - The struct variable node id 
 * @returns the list of types for each struct attribute (or null)
 */
function getStructAttributeTypes(structVarSource, structVarAstId) {
    let structAst = null;
    let structNode = null;
    let structAttributeTypes = [];

    //Get AST where the struct variable is defined
    const buildInfoData = fetch.readBuildInfoFiles();

    for (const buildInfoFile in buildInfoData) {
        const buildInfoFileData = buildInfoData[buildInfoFile];
        const sources = extractSourcesFromBuildInfoFile(buildInfoFileData);

        sources.forEach(source => {
            if (source === structVarSource) {
                structAst = getSourceAST(structVarSource, buildInfoFileData);
            }
        });
        //Get StructDefinition node from AST
        if (structAst !== null) {
            structNode = findASTNodeById(structAst, structVarAstId)
            break;
        };
    }

    if (structNode && structNode.nodeType === "StructDefinition" && structNode.members) {
        structNode.members.forEach(member => {
            structAttributeTypes.push(member.typeName.typeDescriptions.typeIdentifier);
        });
    }
    return structAttributeTypes;
}

/**
 * Determines the values of an enum definition from its AST
 * @param {String} enumVarSource - The enum variable parent source
 * @param {Number} enumVarAstId - The enum variable node id 
 * @returns the list of values in the enum (or null)
 */
function getEnumValues(enumVarSource, enumVarAstId) {
    let enumAst = null;
    let enumNode = null;
    let enumValues = [];

    //Get AST where the struct variable is defined
    const buildInfoData = fetch.readBuildInfoFiles();

    for (const buildInfoFile in buildInfoData) {
        const buildInfoFileData = buildInfoData[buildInfoFile];
        const sources = extractSourcesFromBuildInfoFile(buildInfoFileData);

        sources.forEach(source => {
            if (source === enumVarSource) {
                enumAst = getSourceAST(enumVarSource, buildInfoFileData);
            }
        });
        //Get StructDefinition node from AST
        if (enumAst !== null) {
            enumNode = findASTNodeById(enumAst, enumVarAstId)
            break;
        };
    }

    if (enumNode && enumNode.nodeType === "EnumDefinition") {
        enumNode.members.forEach(member => {
            enumValues.push(member.name);
        });
    }
    return enumValues;
}


/**
 * Gets a node from an AST by its astID
 * @param {Object} ast the AST to examine
 * @param {Object} nodeId the node ID to search
 * @returns the AST node matching nodeId
 */
function findASTNodeById(ast, nodeId) {

    if (ast.id === nodeId) {
        return ast; // Found the node with the specified ID
    }

    for (const key in ast) {
        if (ast[key] && typeof ast[key] === 'object') {
            const result = findASTNodeById(ast[key], nodeId);
            if (result) {
                return result; // Return the node if found in this branch
            }
        }
    }

    return null; // Node with specified ID not found in this subtree
}

/**
 * EXTRACT SLOTS WHERE SPECIFIC VARIABLE VALUES ARE STORED
 */

/**
 * Finds and extracts the slots where the elements of a bytes array are stored.
 * @param {Object} bytesArrayVar - the bytes array variable data
 * @returns {Array} elementSlots - the list of slots where each element is stored
 */
function extractBytesArrayElementSlots(bytesArrayVar) {
    const elementSlots = [];

    // The initial slot stores the length of the byte array, (and its data, if short)
    elementSlots.push(bytesArrayVar.slot);

    // Determine if the array is short or long based on the lowest byte of its value
    const lowestByteDecimal = parseInt(bytesArrayVar.value.slice(-2), 16);
    const arrayLength = (lowestByteDecimal - 1) / 2;
    const nDataSlots = Math.ceil(arrayLength / 32);

    //If this is a long array
    if (arrayLength >= 32) {

        // Compute the first data slot of the array
        const dataSlotKeccak = computeSlotKeccak256(bytesArrayVar.slot);

        for (let i = 0; i < nDataSlots; i++) {
            // Compute slot of ith element
            const elementSlot = '0x' + (BigInt(dataSlotKeccak) + BigInt(i)).toString(16);
            elementSlots.push(elementSlot);
        }
    }

    return elementSlots;
}

/**
 * Finds and extracts the slots where the elements of a fixed array are stored.
 * Array elements always start a new slot even if the element occupies less than 32 bytes.
 * In fixed-size arrays, the array slot contains the value of the first element.
 * @param {Object} fixedArrayVar - the fixed array variable data
* @returns {Array} arrayElementSlots - the list of slots where each element is stored
 */
function extractFixedArrayElementSlots(fixedArrayVar) {
    let arrayElementSlots = [];
    const size = getFixedArrayLength(fixedArrayVar.type);
    const type = getArrayType(fixedArrayVar.type)
    let nSlots = size;

    //Boolean values are packed together in the same slot
    if (type.startsWith("t_bool")) {
        nSlots = Math.ceil(size / 32)
    }

    //The first slot of a fixed array stores its first element
    for (let i = 0; i < nSlots; i++) {

        let elementSlot;

        if (fixedArrayVar.slot.startsWith('0x')) {
            //Sum the initial slot value to the slot index
            const bigIntElementSlot = BigInt(fixedArrayVar.slot) + BigInt(i);
            // Convert the BigInt back to a hexadecimal string of length 32
            elementSlot = ethers.toBeHex('0x' + bigIntElementSlot.toString(16), 32);
        } else {
            elementSlot = parseInt(fixedArrayVar.slot) + i;
        }
        arrayElementSlots.push(elementSlot)
    }
    return arrayElementSlots;
}


/**
 * Finds and extracts the slots where the elements of a dynamic array are stored.
 * The first slot contains the length of the array.
 * Array elements always start a new slot even if the element occupies less than 32 bytes.
 * @param {Object} fixedArrayVar - the fixed array variable data
 * @returns {Array} arrayElementSlots - the list of slots where each element is stored
 */
function extractDynamicArrayElementSlots(dynamicArrayVar) {

    let arrayElementSlots = [];

    const size = getDynamicArrayLength(dynamicArrayVar.value);
    const type = getArrayType(dynamicArrayVar.type);
    const startingSlotKeccak = computeSlotKeccak256(dynamicArrayVar.slot);

    /**
    * If the dynamic array contains static arrays, the start index of each static array must be computed differently
    * For example, if we have a dyn_array containing two fixed_array of lenght 2,
    * the fixed arrays starts at keccak256(dyn_array_slot+0), and keccak256(dyn_array_slot+2)
    * as keccak256(dyn_array_slot+1) contains the second element of the first fixed array
    */
    if (type.startsWith("t_array") && getArrayMutability(type) === "fixed") {
        const fixedArrayType = getArrayType(type)
        const fixedArraySize = getFixedArrayLength(type); // Number of elements in the array

        //Bool values are packed together in a single slot
        let nSlots = fixedArrayType.startsWith("t_bool") ? size * Math.ceil(fixedArraySize / 32) : size * fixedArraySize;
        let step = fixedArrayType.startsWith("t_bool") ? Math.ceil(fixedArraySize / 32) : fixedArraySize;

        for (let i = 0; i < nSlots; i += step) {
            const startingSlotKeccakBigInt = BigInt(startingSlotKeccak);
            const bigIntElementSlot = startingSlotKeccakBigInt + BigInt(i);
            const elementSlot = ethers.toBeHex(bigIntElementSlot, 32);
            arrayElementSlots.push(elementSlot);
        }
    }

    else {
        //Bool values are packed together in a single slot
        let nSlots = type.startsWith("t_bool") ? Math.ceil(size / 32) : size;

        for (let i = 0; i < nSlots; i++) {
            const startingSlotKeccakBigInt = BigInt(startingSlotKeccak);
            const bigIntElementSlot = startingSlotKeccakBigInt + BigInt(i);
            const elementSlot = ethers.toBeHex(bigIntElementSlot, 32);
            arrayElementSlots.push(elementSlot);
        }
    }

    return arrayElementSlots;
}


/**
 * Finds and extracts the slots where the elements of a mapping are stored.
 * @param {Object} mappingVar - the mapping variable data
 * @returns the list of slots where each element is stored
 */
function extractMappingSlots(mappingVar) {
    //@todo this is just a placeholder for the actual mapping keys
    throw new Error("Mapping slots extraction currently not supported - no keys available")
    /*let mappingKeys = [25];
    const abiCoder = new ethers.AbiCoder();
    const elementSlots = []
    mappingKeys.forEach(key => {
        const slotHash = ethers.keccak256(abiCoder.encode(['uint256', 'uint256'], [key, mappingVar.slot]));
        elementSlots.push(slotHash);
    });
    return elementSlots;*/
}

/**
* Finds and extracts the slots where the attributes of a struct are stored.
* @param {Object} structVar - the struct variable data
* @returns the list of slots where each attribute is stored
*/
function extractStructAttributeSlots(structVar) {
    const numberOfSlots = structVar.numberOfBytes / 32;
    let elementSlots = [];
    for (let i = 0; i < numberOfSlots; i++) {
        let elementSlot = parseInt(structVar.slot) + i;
        elementSlots.push(elementSlot)
    }
    return elementSlots;
}

module.exports = {
    decodeStorageValues: decodeStorageValues,
    extractBytesArrayElementSlots: extractBytesArrayElementSlots,
    extractDynamicArrayElementSlots: extractDynamicArrayElementSlots,
    extractFixedArrayElementSlots: extractFixedArrayElementSlots,
    extractStructAttributeSlots: extractStructAttributeSlots,
    extractMappingSlots: extractMappingSlots,
    getArrayMutability: getArrayMutability,
    getArrayType: getArrayType,
    getChangedMappingSlots: getChangedMappingSlots,
    getDynamicArrayLength: getDynamicArrayLength,
    getFixedArrayLength: getFixedArrayLength,
    getStorageLayoutBySource: getStorageLayoutBySource,
    parseSlot: parseSlot
};
